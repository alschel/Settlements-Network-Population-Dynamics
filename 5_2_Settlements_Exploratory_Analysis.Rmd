---
title: "5.2. Settlements Exploratory Analysis"
author: "Alexander Sheludkov"
date: "26 11 2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r libraries, message=FALSE, warning=FALSE}
library(dplyr)
library(tidyr)
library(ggplot2)
library(ggforce)
library(corrplot)
library(caret)
library(RColorBrewer)
library(stargazer)
```

```{r load data}
load(file = "data/Part3_res_dataset.Rdata")
load("data/settlements.Rdata")
```

## Как структурное положение н.п. в сети населенных пунктов влияло на динамику его населения?

Мы будем предсказывать отношение населения н.п. в 2010 году к населению в 2002: `pop2010to2002_rel`

### 1. Preprocessing 

#### 1.1 Чистка данных

 - Удалим населенные пункты, которые исчезли в результате поглощения городами  
 - Выделим из датаеста интересующие нас предикторы  

```{r}
df %>% 
  filter(!(pop2010to2002_rel == 0 & Census2002 > 1000 & MunicipalDistrict == "Тобольский район")) %>%
  filter(!(pop2010to2002_rel == 0 & MunicipalDistrict == "Тюменский район")) %>% 
  dplyr:: select(pop2010to2002_rel, clust_6, clust_18, starts_with("clo"), starts_with("betw")) ->
  df_cleaned
summary(df_cleaned)
```

Проверка на выбросы  

```{r}
df_cleaned %>% 
  ggplot(aes(pop2010to2002_rel))+
  geom_histogram(alpha = 0.7, binwidth = 5)+
  theme_bw()
```

Распределение стремится к нормальному, но есть множество выбросов. Речь идет о небольших деревнях, где даже незначительные изменения в численности населения высокие в процентном выражении.We remove outliers beyond 3*Median Absolute Deviation.  

```{r}
df_cleaned %>% 
  mutate(dev = pop2010to2002_rel - median(pop2010to2002_rel)) %>% 
  filter(dev <= 3*mad(pop2010to2002_rel)) %>% 
  select(-dev) -> df_cleaned

df_cleaned %>% 
  ggplot(aes(pop2010to2002_rel))+
  geom_histogram(alpha = 0.7, binwidth = 5)+
  theme_bw()

summary(df_cleaned)
```


#### 1.2 Отбор предикторов

Проверим предикторы на корреляцию

```{r fig.height=10, fig.width=10}
corr <- cor(df_cleaned)
corrplot(corr, method = "number")
```

Показатели ценральности по посредничеству сильно коррелируют. Составим 2 датасета с разными вариантами ценральности по посредничеству и сравним полученные модели. Сандартизируем переменные.  

```{r}

# Pure metrics
dataset_1 <- df_cleaned %>% 
  select(pop2010to2002_rel, # объясняемая переменная (изменение населения за период)
         clo_CL6,           # closeness centrality (в пределах одного из 6 кластеров)
         clo_CL18,          # closeness centrality (в пределах одного из 18 кластеров)
         betw_CL18,         # betweenness centrality (c максимальной длиной пути, учитываемой при вычислении в 52021.79)
         clust_6, clust_18) # группирующие переменные       

dataset_2 <- df_cleaned %>% 
  select(pop2010to2002_rel, # объясняемая переменная (изменение населения за период)
         clo_CL6,           # closeness centrality (в пределах одного из 6 кластеров)
         clo_CL18,          # closeness centrality (в пределах одного из 18 кластеров)
         betw_CL6,          # betweenness centrality (c максимальной длиной пути, учитываемой при вычислении в 98245.06 км)
         clust_6, clust_18)

dataset_3 <- dataset_1 %>% 
  mutate_at(.vars = vars(clo_CL6, clo_CL18, betw_CL18), scale)

dataset_4 <- dataset_2 %>% 
  mutate_at(.vars = vars(clo_CL6, clo_CL18, betw_CL6), scale)
```

### 2. Model

```{r message=TRUE, warning=TRUE}
model1 <- lmer(pop2010to2002_rel ~ clo_CL6 + clo_CL18 + betw_CL18 + (1|clust_6/clust_18) + (0 + clo_CL6|clust_6) + (0 + clo_CL18|clust_18), REML = F, data = dataset_1)
model2 <- lmer(pop2010to2002_rel ~ clo_CL6 + clo_CL18 + betw_CL6 + (1|clust_6/clust_18) + (0 + clo_CL6|clust_6) + (0 + clo_CL18|clust_18), REML = F, data = dataset_2)

model3 <- lmer(pop2010to2002_rel ~ clo_CL6 + clo_CL18 + betw_CL18 + (1|clust_6/clust_18) + (0 + clo_CL6|clust_6) + (0 + clo_CL18|clust_18), REML = F, data = dataset_3)
model4 <- lmer(pop2010to2002_rel ~ clo_CL6 + clo_CL18 + betw_CL6 + (1|clust_6/clust_18) + (0 + clo_CL6|clust_6) + (0 + clo_CL18|clust_18), REML = F, data = dataset_4)
```

Compare the results  

```{r}
stargazer::stargazer(model1, model2, model3, model4, type = "text")
```

```{r}

# df %>% 
#   ggplot(aes(y = pop2010to2002_rel, x = clo_CL6, col = as.factor(clust_6)))+
#   geom_point()+
#   geom_smooth(method = "glm")

# 
MuMIn::r.squaredGLMM(model2)
MuMIn::r.squaredGLMM(model4)

stdCoef.merMod <- function(object) {
  sdy <- sd(getME(object,"y"))
  sdx <- apply(getME(object,"X"), 2, sd)
  sc <- fixef(object)*sdx/sdy
  se.fixef <- coef(summary(object))[,"Std. Error"]
  se <- se.fixef*sdx/sdy
  return(data.frame(stdcoef=sc, stdse=se))
}

stdCoef.merMod(model3)
stdCoef.merMod(model1)

```