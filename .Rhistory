ggplot(aes(x = CL18_centr_betw, y = CL18_pop2010to2002_rel))+
geom_point()
clusters_18_metrics %>%
ggplot(aes(x = CL18_centr_clo, y = CL18_variance_dif))+
geom_point()
clusters_18_metrics %>%
ggplot(aes(x = CL18_centr_betw, y = CL18_variance_dif))+
geom_point()
# Quick explorative analysis
# Удаленность от Тюмени vs динамика населения
clusters_18_metrics %>%
ggplot(aes(x=CL18_dist2Tyumen/1000, y=CL18_pop2010to2002_rel))+
geom_point(aes(size = CL18_mean_pop2002))+
geom_smooth(method = "glm")
library(sp)
library(sf)
library(raster)
library(dplyr)
library(ggplot2)
library(gridExtra)
library(igraph)
library(RColorBrewer)
library(tidyr)
library(viridis)
# load the data
load("data/Part2_output.RData")
# 1.1. Сохраним данные в новую переменную и очистим от лишних столбцов
df <- settlements_2002@data
df %>%
select(-Rosstat1981, -cohort1981, -cohort1990, -cohort2002,
-trend_1981to1990, -trend_1990to2002, -trend_2002to2010,
-rel1981to1990, -rel1990to2002, -rel2002to2010) -> df
df %>%
dplyr::select(-Rosstat1981, -cohort1981, -cohort1990, -cohort2002,
-trend_1981to1990, -trend_1990to2002, -trend_2002to2010,
-rel1981to1990, -rel1990to2002, -rel2002to2010) -> df
# Add coordinates of the settlements as new columns
df %>%
mutate(lon = coordinates(settlements_2002)[,1],
lat = coordinates(settlements_2002)[,2]) %>%
dplyr::select(id, lon, lat, ShortName, MunicipalDistrict,
Rosstat1990, Census2002, Census2010, clust_3, clust_6, clust_18) -> df
my_subgraph_function <- function(graph, nodes) {
# 1) сохраним в отдельный вектор номера всех вершин, лежащих между н.п.
# shortest_paths() возвращает именованный list длины @to,
# который содержит индексы всех вершин и ребер каждого пути
all_the_verticies <-
shortest_paths(graph = graph,        # igraph object
from = nodes,         # vertex ids from
to = nodes) %>%       # vertex ids to
.$vpath %>%                          # extract list of returned vertex ids
unlist()                             # unlist
# 2) выборка из графа
induced_subgraph(graph = graph,                        # igraph object
vids = all_the_verticies) %>%         # vertex ids
simplify() ->                                        # remove loop and multiple edges
sub_graph
return(sub_graph)
}
rep.row <-function(x,n){
matrix(rep(x,each=n),nrow=n)
}
rep.col <-function(x,n){
matrix(rep(x,each=n),ncol=n)
}
# 1.4. Define function for normalizing data
normalize <- function(x) {
return ((x - min(x)) / (max(x) - min(x)))
}
# ======================================
# 2.1. Descriptive metrics on population
df %>%
group_by(clust_6) %>%
mutate(CL6_n = n(),
CL6_pop2002 = sum(Census2002),                        # 2002 population
CL6_pop2010 = sum(Census2010),                        # 2010 population общая численность населения
CL6_pop2010to2002_rel = CL6_pop2010/CL6_pop2002*100,  # percentage of 2010-population to 2002-population
CL6_max_pop2002 = max(Census2002),                    # the largest settlement's size
CL6_mean_pop2002 = mean(Census2002),                  # mean settlement's size
CL6_median_pop2002 = median(Census2002)) %>%          # median settlement's size
# select the columns we need
select(clust_6, CL6_n, CL6_pop2002, CL6_pop2010, CL6_pop2010to2002_rel,
CL6_max_pop2002, CL6_mean_pop2002, CL6_median_pop2002) %>%
unique() -> clusters_6_metrics    # Save the results into new data.frame
# ======================================
# 2.1. Descriptive metrics on population
df %>%
group_by(clust_6) %>%
mutate(CL6_n = n(),
CL6_pop2002 = sum(Census2002),                        # 2002 population
CL6_pop2010 = sum(Census2010),                        # 2010 population общая численность населения
CL6_pop2010to2002_rel = CL6_pop2010/CL6_pop2002*100,  # percentage of 2010-population to 2002-population
CL6_max_pop2002 = max(Census2002),                    # the largest settlement's size
CL6_mean_pop2002 = mean(Census2002),                  # mean settlement's size
CL6_median_pop2002 = median(Census2002)) %>%          # median settlement's size
# select the columns we need
dplyr::select(clust_6, CL6_n, CL6_pop2002, CL6_pop2010, CL6_pop2010to2002_rel,
CL6_max_pop2002, CL6_mean_pop2002, CL6_median_pop2002) %>%
unique() -> clusters_6_metrics    # Save the results into new data.frame
# Create new columns
clusters_6_metrics$CL6_variance_2002 <- NA_real_
clusters_6_metrics$CL6_variance_2010 <- NA_real_
for (i in 1:nrow(clusters_6_metrics)) {
# Define logical vector to subset observations by the cluster
select_condition <- clust_6_2002 == i
settlements_temp <- df[select_condition,]
# Calculate variance (standard deviation(x)/mean(x))
# 2002
clusters_6_metrics[clusters_6_metrics$clust_6 == i,]$CL6_variance_2002 <-
sd(settlements_temp$Census2002, na.rm = T)/mean(settlements_temp$Census2002, na.rm = T)
# 2010
clusters_6_metrics[clusters_6_metrics$clust_6 == i,]$CL6_variance_2010 <-
sd(settlements_temp$Census2010, na.rm = T)/mean(settlements_temp$Census2010, na.rm = T)
}
# Calculate the difference in variance between 2002 and 2010 (темпы сжатия расселения)
clusters_6_metrics %>%
mutate(CL6_variance_dif = CL6_variance_2010/CL6_variance_2002*100) ->
clusters_6_metrics
# 3.2.1. Quick explorative analysis
# Темпы сжатия расселения vs общая динамика населения
clusters_6_metrics %>%
ggplot(aes(y=CL6_variance_dif, x=CL6_pop2010to2002_rel))+
geom_point(aes(size = CL6_mean_pop2002))+
geom_smooth(method = "glm")+
scale_size_continuous(name = "Ср. размер\nн.п. (чел.)", breaks = c(0, 500, 2000))+
scale_y_continuous(name = "Динамика территориальной\nдифференциации расселения") +
scale_x_continuous(name = "Население в 2010 году к населению в 2002, %")
# Создадим переменную
clusters_6_metrics$CL6_density <- NA_real_
# Calculate
for (i in 1:nrow(clusters_6_metrics)) {
# Define logical vector to subset settlements by the cluster
select_condition <- clust_6_2002 == i
# Create subgraph
temp_graph <- my_subgraph_function(res_graph_2002, settl_index_2002[select_condition])
# Calculate edge_density
clusters_6_metrics[clusters_6_metrics$clust_6 == i,]$CL6_density <- edge_density(temp_graph)
}
# Quick explorative analysis:
# PopDynamics vs Density
clusters_6_metrics %>%
ggplot(aes(x = CL6_density, y = CL6_pop2010to2002_rel))+
geom_point(aes(size = CL6_mean_pop2002))+
# geom_smooth(col = "grey")+
geom_text(aes(x = CL6_density, y = CL6_pop2010to2002_rel - 1, label = clust_6))
# Var_dif vs Density
clusters_6_metrics %>%
ggplot(aes(x = CL6_density, y = CL6_variance_dif))+
# geom_smooth()+
geom_point(aes(size = CL6_mean_pop2002))+
geom_text(aes(x = CL6_density, y = CL6_variance_dif + 0.5,  label = clust_6))
# Quick explorative analysis:
# PopDynamics vs Density
clusters_6_metrics %>%
ggplot(aes(x = CL6_density, y = CL6_pop2010to2002_rel))+
geom_point(aes(size = CL6_mean_pop2002))+
# geom_smooth(col = "grey")+
geom_text(aes(x = CL6_density, y = CL6_pop2010to2002_rel - 1, label = clust_6))
# Betweenness Centralisation (централизация по посредничеству)
# Create column
clusters_6_metrics$CL6_centr_betw <- NA_real_
# Calculate
for (i in 1:nrow(clusters_6_metrics)) {
# Define logical vector to subset settlements by the cluster
select_condition <- clust_6_2002 == i
# Create subgraph
temp_graph <- my_subgraph_function(res_graph_2002, settl_index_2002[select_condition])
# Calculate edge_density
clusters_6_metrics[clusters_6_metrics$clust_6 == i,]$CL6_centr_betw <- centr_betw(temp_graph, normalized = T)$centralization
}
# Closeness Centralisation (централизация по близости)
# Create column
clusters_6_metrics$CL6_centr_clo<- NA_real_
# Calculate
for (i in 1:nrow(clusters_6_metrics)) {
# Define logical vector to subset settlements by the cluster
select_condition <- clust_6_2002 == i
# Create subgraph
temp_graph <- my_subgraph_function(res_graph_2002, settl_index_2002[select_condition])
# Calculate edge_density
clusters_6_metrics[clusters_6_metrics$clust_6 == i,]$CL6_centr_clo <- centr_clo(temp_graph, normalized = T)$centralization
}
# Quick explorative analysis:
# Var_dif vs centr_betw
clusters_6_metrics %>%
ggplot(aes(x = CL6_centr_betw, y = CL6_variance_dif))+
# geom_smooth()+
geom_point(aes(size = CL6_mean_pop2002))+
geom_text(aes(x = CL6_centr_betw+0.001, y = CL6_variance_dif + 0.5, label = clust_6))
# PopDyn vs centr_betw
clusters_6_metrics %>%
ggplot(aes(x = CL6_centr_betw, y = CL6_pop2010to2002_rel))+
# geom_smooth()+
geom_point(aes(size = CL6_mean_pop2002))+
geom_text(aes(x = CL6_centr_betw+0.01, y = CL6_pop2010to2002_rel - 0.5, label = clust_6))
# Var_dif vs centr_betw
clusters_6_metrics %>%
ggplot(aes(x = CL6_centr_clo, y = CL6_variance_dif))+
# geom_smooth()+
geom_point(aes(size = CL6_mean_pop2002))+
geom_text(aes(x = CL6_centr_clo+0.001, y = CL6_variance_dif + 0.5, label = clust_6))
clusters_6_metrics$CL6_dist2Tyumen <- NA_real_
for (i in 1:nrow(clusters_6_metrics)) {
# Define logical vector to subset observations by the cluster
select_condition <- clust_6_2002 == i
settlements_temp <- df[select_condition,]
# Subset distance matrix: by row - cluster members, by column - Tyumen
distances_to_Tyumen <- dist_matrix_2002[select_condition, df$ShortName == "г. Тюмень"]
# Weight by population proportion
res <- sum(distances_to_Tyumen * settlements_temp$Census2002/sum(settlements_temp$Census2002))
# Save to res cell
clusters_6_metrics[clusters_6_metrics$clust_6 == i,]$CL6_dist2Tyumen <- res
}
# ======================================
# 3.1. Descriptive metrics on population
df %>%
group_by(clust_18) %>%
mutate(CL18_n = n(),                                          # Number of settlements
CL18_pop2002 = sum(Census2002),                        # 2002 population
CL18_pop2010 = sum(Census2010),                        # 2010 population общая численность населения
CL18_pop2010to2002_rel = CL18_pop2010/CL18_pop2002*100,  # percentage of 2010-population to 2002-population
CL18_max_pop2002 = max(Census2002),                    # the largest settlement's size
CL18_mean_pop2002 = mean(Census2002),                  # mean settlement's size
CL18_median_pop2002 = median(Census2002)) %>%          # median settlement's size
# select the columns we need
select(clust_6, clust_18, CL18_pop2002, CL18_pop2010, CL18_pop2010to2002_rel,
CL18_max_pop2002, CL18_mean_pop2002, CL18_median_pop2002) %>%
unique() -> clusters_18_metrics    # Save the results into new data.frame
# ======================================
# 3.1. Descriptive metrics on population
df %>%
group_by(clust_18) %>%
mutate(CL18_n = n(),                                          # Number of settlements
CL18_pop2002 = sum(Census2002),                        # 2002 population
CL18_pop2010 = sum(Census2010),                        # 2010 population общая численность населения
CL18_pop2010to2002_rel = CL18_pop2010/CL18_pop2002*100,  # percentage of 2010-population to 2002-population
CL18_max_pop2002 = max(Census2002),                    # the largest settlement's size
CL18_mean_pop2002 = mean(Census2002),                  # mean settlement's size
CL18_median_pop2002 = median(Census2002)) %>%          # median settlement's size
# select the columns we need
dplyr::select(clust_6, clust_18, CL18_pop2002, CL18_pop2010, CL18_pop2010to2002_rel,
CL18_max_pop2002, CL18_mean_pop2002, CL18_median_pop2002) %>%
unique() -> clusters_18_metrics    # Save the results into new data.frame
# Create new columns
clusters_18_metrics$CL18_variance_2002 <- NA_real_
clusters_18_metrics$CL18_variance_2010 <- NA_real_
for (i in 1:nrow(clusters_18_metrics)) {
# Define logical vector to subset observations by the cluster
select_condition <- clust_18_2002 == i
settlements_temp <- df[select_condition,]
# Calculate variation (standart deviation(x)/mean(x))
# 2002
clusters_18_metrics[clusters_18_metrics$clust_18 == i,]$CL18_variance_2002 <-
sd(settlements_temp$Census2002, na.rm = T)/mean(settlements_temp$Census2002, na.rm = T)
# 2010
clusters_18_metrics[clusters_18_metrics$clust_18 == i,]$CL18_variance_2010 <-
sd(settlements_temp$Census2010, na.rm = T)/mean(settlements_temp$Census2010, na.rm = T)
}
# Calculate the difference in variance between 2002 and 2010 (темпы сжатия расселения)
clusters_18_metrics %>%
mutate(CL18_variance_dif = CL18_variance_2010/CL18_variance_2002*100) ->
clusters_18_metrics
# Темпы сжатия расселения vs общая динамика населения
clusters_18_metrics %>%
ggplot(aes(y=CL18_variance_dif, x=CL18_pop2010to2002_rel))+
geom_point(aes(size = CL18_mean_pop2002))+
# geom_smooth(method = "glm")+
scale_size_continuous(name = "Ср. размер\nн.п. (чел.)",
breaks = c(0, 300, 500, 1000, 2000), trans = "sqrt",
labels = c("<300", "300-499", "500-999", "1000-2000", ">8000"))+
scale_y_continuous(name = "Динамика территориальной\nдифференциации расселения", breaks = seq(100, 115, 5),
limits = c(100,115))+
scale_x_continuous(name = "Динамика населения (%)")
# Темпы сжатия расселения vs средний размер населенных пунктов
clusters_18_metrics %>%
ggplot(aes(y=CL18_mean_pop2002, x=CL18_variance_dif))+
geom_point()+
# geom_smooth(method = "glm")+
scale_y_continuous(trans = "log")+
scale_x_continuous(name = "Изменение вариации")
# Темпы сжатия расселения vs средний размер населенных пунктов
clusters_18_metrics %>%
ggplot(aes(x=CL18_mean_pop2002, y=CL18_variance_dif))+
geom_point()+
# geom_smooth(method = "glm")+
scale_y_continuous(trans = "log")+
scale_x_continuous(name = "Изменение вариации")
# Темпы сжатия расселения vs средний размер населенных пунктов
clusters_18_metrics %>%
ggplot(aes(x=CL18_mean_pop2002, y=CL18_variance_dif))+
geom_point()+
# geom_smooth(method = "glm")+
scale_x_continuous(trans = "log")+
scale_y_continuous(name = "Изменение вариации")
# Темпы сжатия расселения vs средний размер населенных пунктов
clusters_18_metrics %>%
ggplot(aes(x=CL18_mean_pop2002, y=CL18_variance_dif))+
geom_point()+
# geom_smooth(method = "glm")+
scale_x_continuous(trans = "log")+
scale_y_continuous(name = "Изменение вариации")
# Create column
clusters_18_metrics$CL18_density <- NA_real_
# Calculate
for (i in 1:nrow(clusters_18_metrics)) {
# Define logical vector to subset settlements by the cluster
select_condition <- clust_18_2002 == i
# Create subgraph
temp_graph <- my_subgraph_function(res_graph_2002, settl_index_2002[select_condition])
# Calculate edge_density
clusters_18_metrics[clusters_18_metrics$clust_18 == i,]$CL18_density <- edge_density(temp_graph)
}
# Quick explorative analysis:
# PopDynamics vs Density
clusters_18_metrics %>%
ggplot(aes(x = CL18_density, y = CL18_pop2010to2002_rel))+
geom_point(aes(size = CL18_mean_pop2002))+
# geom_smooth(col = "grey")+
geom_text(aes(x = CL18_density+0.001, y = CL18_pop2010to2002_rel - 0.5, label = clust_18))
# Var_dif vs Density
clusters_18_metrics %>%
ggplot(aes(x = CL18_density, y = CL18_variance_dif))+
# geom_smooth()+
geom_point(aes(size = CL18_mean_pop2002))+
geom_text(aes(x = CL18_density, y = CL18_variance_dif + 0.5,  label = clust_6))
clusters_18_metrics %>%
ggplot(aes(x = CL18_density, y = CL18_variance_dif))+
geom_point()+
geom_smooth(method = "glm")
clusters_18_metrics %>%
ggplot(aes(x = CL18_density, y = CL18_variance_dif))+
# geom_smooth()+
geom_point(aes(size = CL18_mean_pop2002))+
geom_text(aes(x = CL18_density, y = CL18_variance_dif + 0.5,  label = clust_6))
# Quick explorative analysis:
# PopDynamics vs Density
clusters_18_metrics %>%
ggplot(aes(x = CL18_density, y = CL18_pop2010to2002_rel))+
geom_point(aes(size = CL18_mean_pop2002))+
# geom_smooth(col = "grey")+
geom_text(aes(x = CL18_density+0.001, y = CL18_pop2010to2002_rel - 0.5, label = clust_18))
# Betweenness Centralisation (централизация по посредничеству)
# Create column
clusters_18_metrics$CL18_centr_betw <- NA_real_
# Calculate
for (i in 1:nrow(clusters_18_metrics)) {
# Define logical vector to subset settlements by the cluster
select_condition <- clust_18_2002 == i
# Create subgraph
temp_graph <- my_subgraph_function(res_graph_2002, settl_index_2002[select_condition])
# Calculate edge_density
clusters_18_metrics[clusters_18_metrics$clust_18 == i,]$CL18_centr_betw <- centr_betw(temp_graph, normalized = T)$centralization
}
# Closeness Centralisation (централизация по близости)
# Create column
clusters_18_metrics$CL18_centr_clo <- NA_real_
# Calculate
for (i in 1:nrow(clusters_18_metrics)) {
# Define logical vector to subset settlements by the cluster
select_condition <- clust_18_2002 == i
# Create subgraph
temp_graph <- my_subgraph_function(res_graph_2002, settl_index_2002[select_condition])
# Calculate edge_density
clusters_18_metrics[clusters_18_metrics$clust_18 == i,]$CL18_centr_clo <- centr_clo(temp_graph, normalized = T)$centralization
}
# Quick explorative analysis:
# Var_dif vs centr_betw
clusters_18_metrics %>%
ggplot(aes(x = CL18_centr_betw, y = CL18_variance_dif))+
# geom_smooth()+
geom_point(aes(size = CL18_mean_pop2002))+
geom_text(aes(x = CL18_centr_betw+0.001, y = CL18_variance_dif + 0.5, label = clust_6))
clusters_18_metrics$CL18_dist2Tyumen <- NA_real_
for (i in 1:nrow(clusters_18_metrics)) {
# Define logical vector to subset observations by the cluster
select_condition <- clust_18_2002 == i
settlements_temp <- df[select_condition,]
# Subset distance matrix: by row - cluster members, by column - Tyumen
distances_to_Tyumen <- dist_matrix_2002[select_condition, df$ShortName == "г. Тюмень"]
# Weight by population proportion
res <- sum(distances_to_Tyumen * settlements_temp$Census2002/sum(settlements_temp$Census2002))
# Save to res cell
clusters_18_metrics[clusters_18_metrics$clust_18 == i,]$CL18_dist2Tyumen <- res
}
# =====================================
# 4.1. Distance to the regional capital
df$dist2Tyumen <- dist_matrix_2002[,which(settlements_2002$ShortName == "г. Тюмень")]
# ==========================
# 4.1.1 Populationn dynamics
df %>%
mutate(pop2010to2002_rel = Census2010/Census2002*100) -> df
# 4.2.1. Closeness centrality
df$clo <- 1/(dist_matrix_2002 %>% apply(1, sum))
# Create matrix of population sizes in 2002
pop_2002_matrix <- rep.row(normalize(settlements_2002$Census2002),
nrow(dist_matrix_2002))
# Calculate distance matrices, weighted by population (_w)
dist_matrix_2002_w <- dist_matrix_2002 * pop_2002_matrix
# Calculate centrality closeness, weightened by population
df$clo_w <- 1/(dist_matrix_2002_w %>% apply(1, sum))
# How relate 'pure' closeness centrality to the weighted one?
df %>%
ggplot(aes(x = clo, y = clo_w, col= as.factor(clust_6)))+
geom_point()
df$clo_CL6 <- NA_real_
# Calculate
for (i in 1:nrow(clusters_6_metrics)) {
# Define logical vector to subset settlements by the cluster
select_condition <- clust_6_2002 == i
# Subset distance matrix
temp_matrix <- dist_matrix_2002[select_condition, select_condition]
# Calculate edge_density
df[df$clust_6 == i,]$clo_CL6 <- 1/(temp_matrix %>% apply(1, sum))
}
df$clo_CL6_w <- NA_real_
# Calculate
for (i in 1:nrow(clusters_6_metrics)) {
# Define logical vector to subset settlements by the cluster
select_condition <- clust_6_2002 == i
# Subset distance matrix
temp_matrix <- dist_matrix_2002[select_condition, select_condition]
# Create matrix of population sizes in 2002
temp_pop_matrix <- rep.row(normalize(settlements_2002[select_condition,]$Census2002),
nrow(temp_matrix))
# Calculate distance matrices, weighted by population (_w)
temp_matrix_w <- temp_matrix * temp_pop_matrix
# Calculate edge_density
df[df$clust_6 == i,]$clo_CL6_w <- 1/(temp_matrix_w %>% apply(1, sum, na.rm = T))
}
df$clo_CL18 <- NA_real_
# Calculate
for (i in 1:nrow(clusters_18_metrics)) {
# Define logical vector to subset settlements by the cluster
select_condition <- clust_18_2002 == i
# Subset distance matrix
temp_matrix <- dist_matrix_2002[select_condition, select_condition]
# Calculate edge_density
df[df$clust_18 == i,]$clo_CL18 <- 1/(temp_matrix %>% apply(1, sum))
}
df$clo_CL18_w <- NA_real_
# Calculate
for (i in 1:nrow(clusters_18_metrics)) {
# Define logical vector to subset settlements by the cluster
select_condition <- clust_18_2002 == i
# Subset distance matrix
temp_matrix <- dist_matrix_2002[select_condition, select_condition]
# Create matrix of population sizes in 2002
temp_pop_matrix <- rep.row(normalize(settlements_2002[select_condition,]$Census2002),
nrow(temp_matrix))
# Calculate distance matrices, weighted by population (_w)
temp_matrix_w <- temp_matrix * temp_pop_matrix
# Calculate edge_density
df[df$clust_18 == i,]$clo_CL18_w <- 1/(temp_matrix_w %>% apply(1, sum, na.rm = T))
}
# 6 clusters
clusters_6_metrics$CL6_median_path <- NA_real_
# Calculate
for (i in 1:nrow(clusters_6_metrics)) {
# Define logical vector to subset settlements by the cluster
select_condition <- clust_6_2002 == i
# Subset distance matrix
temp_matrix <- dist_matrix_2002[select_condition, select_condition]
# Calculate edge_density
clusters_6_metrics[clusters_6_metrics$clust_6 == i,]$CL6_median_path <- median(temp_matrix)
}
# 18 clusters
clusters_18_metrics$CL18_median_path <- NA_real_
# Calculate
for (i in 1:nrow(clusters_18_metrics)) {
# Define logical vector to subset settlements by the cluster
select_condition <- clust_18_2002 == i
# Subset distance matrix
temp_matrix <- dist_matrix_2002[select_condition, select_condition]
# Calculate edge_density
clusters_18_metrics[clusters_18_metrics$clust_18 == i,]$CL18_median_path <- median(temp_matrix)
}
df$betw_CL6 <- estimate_betweenness(graph = res_graph_2002,
vids = settl_index_2002,
cutoff = median(clusters_6_metrics$CL6_median_path))
df$betw_CL18 <- estimate_betweenness(graph = res_graph_2002,
vids = settl_index_2002,
cutoff = median(clusters_18_metrics$CL18_median_path))
# Distribution of values
df %>%
ggplot(aes(x = betw_CL18))+
geom_density()
df %>%
ggplot(aes(x = betw_CL6))+
geom_density()
# Distributions are similiar. Let's compare the values?
df %>%
ggplot(aes(x = betw_CL18, y = betw_CL6))+
geom_point()
cor(df$betw_CL18, df$betw_CL6) # 0.86 - the values are highly correlated.
# Betweenness Centrality vs Population Dynamics
df %>%
filter(pop2010to2002_rel < 200) %>%
ggplot(aes(x = betw_CL6, y = pop2010to2002_rel))+
geom_point(aes(col = betw_CL6), alpha = 0.4)+
geom_smooth(method = "glm")+
scale_colour_gradientn(colours = viridis(7), trans = "sqrt")
# Combine all the metrics into a single dataset
df %>%
left_join(clusters_6_metrics, by = "clust_6") %>%
left_join(clusters_18_metrics %>% select(-clust_6), by = "clust_18") -> df
# Combine all the metrics into a single dataset
df %>%
left_join(clusters_6_metrics, by = "clust_6") %>%
left_join(clusters_18_metrics %>% dplyr::select(-clust_6), by = "clust_18") -> df
View(df)
# Save datasets into Rdatafile
save(df, clusters_6_metrics, clusters_18_metrics, file = "data/Part3_res_dataset.Rdata")
